<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Response对象笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Response重定向的方法,和路径填写. 注意,转发因为实在服务器内部发生资源跳转,所以不需要写绝对路径,相对路径即可.Response字符输出流,注意设置编码格式防止中文乱码,获取流的默认格式是ISO-8859-1的 注意,再获取流对象之前,设置编码,而不是再之后设置编码.Response字节输出流,设置编码格式,防止中文乱码,同字符输出流相同,只不过字节流可以输出更多东西.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Response]]></title>
    <url>%2F2019%2F07%2F18%2FResponse%2F</url>
    <content type="text"><![CDATA[响应消息: 格式:响应行,响应头,响应空行,响应体. 响应行: 协议/版本,状态码 状态码:服务器告诉客户端浏览器本次请求和响应的状态. *分类: 第一类:1xx,服务器接收客户端消息,但没有接受完成,等待一段时间后,发送1xx状态码. 第二类:2xx,成功! 第三类:3xx,重定向,302代表资源跳转,304,缓存. 第四类:4xx,客户端错误.404代表请求路径没有对应的资源.,405代表请求方式没有对应的doxxx方法. 第五类:5xx,服务器错误.500代表服务器内部出现异常. 响应头: 格式:头名称 值 常见的响应头: Content-type:页面编码格式. Content-Length:字节数. Content-disposition: 服务器告诉客户端以什么格式打开响应体.默认值in-line:在当前页面打开. attachment:以附件形式打开,文件下载. Response设置响应消息: 设置响应行: 设置状态码:setStatus(int i). 设置响应头: setHeader(String name,String values)/(&quot;location&quot;,&quot;资源路径&quot;).这是重定向方法.需要加虚拟路径. 还有一种方法,Response.sendRidrect(&quot;资源路径&quot;).需要加虚拟路径. ★:重定向特点:两次请求,两次响应,不是内部跳转,而是服务器两次请求跳转.地址栏改变. 可以访问服务器外资源. 重定向不能使用request对象的共享数据. 设置相应体: 通过流,首先要获取流, 获取输出流, ★注意!解决乱码:response.setConentType(&quot;text/html;charset=utf-8&quot;); 第一种,字符流:Printer getWriter().不是实时打印.是一次响应完成后打印. 第二种,字节流:ServletOutputStream getOutputStream().]]></content>
  </entry>
  <entry>
    <title><![CDATA[Servlet、HttpServlet、ServletRequest、HttpServletRequest/Response的联系和区别]]></title>
    <url>%2F2019%2F07%2F17%2Fervlet%E3%80%81HttpServlet%E3%80%81ServletRequest%E3%80%81HttpServletRequest%E3%80%81Request%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近在网上读到文章,理论上Servlet可以处理多种方式得请求和响应,http只是其中之一,那么,说明HttpServlet中的请求和响应,也是Servlet得其中之一,说明HttpServletrequest,和HttpServletresponse,是Servlet中得request和response得子类. 当然,继承父类,有父类得属性,之所以继承,肯定子类得有自己特有的东西,HttpServlet中,多了针对Http协议多种消息处理方法,例如,getHeader(),getSession()、getMethod()等等.. Servlet框架,这个框架是由java.servlet和javax.servlet.http,这两个包,组成得,再java.servlet中,规定了一个servlet类必须扩展和实现得通用接口和类.当以后别人问到你,一个servlet需要做什么,你就应该这么说.实现java.servlet包下得servlet接口并重写里面的方法,具体servlet接口分了子类,继承或者实现,取决于选择. Servlet的框架的核心是javax.servlet.Servlet接口,所有的Servlet都必须实现这一接口.在Servlet接口中定义了5个方法,其中有3个方法代表了Servlet的生命周期: init方法,在服务器开始的时候,初始化servlet对象,servlet对象是单例多线程得. service方法,负责响应客户的请求. destroy方法,结束servlet生命周期得方法.Servlet中重要的对象 ★ServletConfig: 获取途径:getServletConfig():该对象包含的方法有这几个... getServletName():返回一个字符串,用来获取该Servlet配置信息中得ServletName的,也就是web.xml配置的那个名字.. getInitParameter(String var1):获取在servlet中初始化参数的值。这里注意与全局初始化参数的区分。这个获取的只是在该servlet下的初始化参数.. getInitParameterNames():获取在Servlet中所有初始化参数的名字，也就是key值，可以通过key值，来找到各个初始化参数的value值。注意返回的是枚举类型.. 该方法返回的类型可以当作是一个迭代器,使用该类型对象方法来获取里面的值.. ★getServletContext():tomcat为每个web项目都创建一个ServletContext实例，tomcat在启动时创建，服务器关闭时销毁，在一个web项目中共享数据，管理web项目资源，为整个web配置公共信息等，通俗点讲，就是一个web项目，就存在一个ServletContext实例，每个Servlet都可以访问到它。 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) * 域对象：共享数据 1. setAttribute(String name,Object value) 2.getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) 本质是字符串拼接. Context对象代表web工程的根目录,拼接参数中的资源路径. String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a); 然后来说说Servlet的单例模式,一个Servlet只能被实例化一次,但是是多线程的,单例多线程,每个servlet类只能实例化自己一次,在服务器启动的时候,但是该实例化的对象会开启多个线程去使用,单例的好处,减少了GC的负担,但是需要注意数据共享的安全. 同步代码块:这样可以解决数据共享的问题,但是,同一时刻只能允许一个客户进行操作访问服务器,其余的需要排队等待,显然这是不可行的. 那么,如果再代码块中,避开实例变量,定义线程方法中的局部变量,这样互不影响,也就避免了数据共享的问题.推荐使用,用户也不用排队等待.Request对象/Response对象: 1.request原理:tomcat会通过请求url中的资源路径,去创建对应的Servlet的对象. 2.tomcat会创建两个对象,request对象中,封装请求数据消息. 3.tomcat将request和response对象传递给service方法,并且调用该方法. 4.程序员可以通过request对象,来获取请求消息数,可以通过设置response对象来设置响应消息. 5.从response中获取响应消息,返回给客户. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat). * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (★)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (★)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr()其父类的方法. 2.获取请求头数据 *方法: (★)String getHeader(String name):通过请求头的名称获取请求头. Enumeration&lt;String&gt; getHeaderNames():获取所有请求头,返回的是枚举.可以理解为迭代器. 3.获取请求体数据 方法: 获取字符流数据.BufferedReader getReader() 获取字节流数据.ServletInputStreame getInputstream() 再从流对象中拿数据.其他功能: 获取请求参数 *String getParameter(String name):根据参数名称,获取参数值. *String [] getParameterValues(String name):作用于复选框. *Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称. *Map&lt;String,String[]&gt; getParameterMap():获取所有参数的Map集合. 使用方法如下: 如果出现乱码,在获取参数前,通过request.setCharacterEncoding(&quot;页面中的编码&quot;). 请求转发:一种在服务器内部的资源跳转方式. 步骤: 通过request.getRequestDispatcher(&quot;要跳转的servlet的路径&quot;).forward(req,reqs) 特点: 转发后的浏览器地址栏路径不会变化,再当前servlet的资源路径跳转. 因为是服务器内部转发,不能转发当前tomcat容器外的servlet.只能访问当前服务器内部的servlet,所以方法参数中的路径不用加上虚拟路径. 转发是一次请求,多个资源之间使用的是同一次请求. 共享数据: 域对象.一个有作用范围的对象,可以在范围内共享数据. request域,代表一次请求,一般用于请求转发的多个资源中共享数据. 方法 setAttribute(String name,Object obj):储存数据. Object getAttribute(String name):通过键获取值. void removeAttribute(String name):通过键移除键值对. 获取ServletContext: ServletContext getServletContext():获取ServletContext对象.]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet体系结构]]></title>
    <url>%2F2019%2F07%2F15%2Fervlet-HTTP-Request%2F</url>
    <content type="text"><![CDATA[Servlet 本身是一个接口,里面包含了init,servi,destroy,getservletinfo,getservletconfig等方法,程序员需要去定义一个类,用来实现这个接口,重写里面的方法,来实现客户端的访问请求 原理:客户端发送url请求,服务器(Tomcat)接收请求以后,实例化Servlet对象(与此同时,会产生一个包含请求数据信息的Request对象),通过配置信息web.xml或者JDK6以上可以使用注解配置servlet中的url-patten,来寻找对应的serlvet,找到对应的servlet后,通过反射找到对应的实现类,然后去执行类中的service方法(Requset,Response),此时会产生Response对象,将处理过后包含请求的数据信息,响应给客户. GenericServlet 实现了Servlet接口的一个抽象类,里面重写了Servlet中的方法.其中,除了service(Requset,Response)方法是抽象方法外,其余的方法都是public,该类主要目的是为了减少代码,避免代码冗余,一开始程序员需要实现Servlet接口,必须重写其中的方法,但是借助中间类GenericServlet,该类实现了Servlet接口,重写了其中的方法,程序员只用继承该类,实现其中的service方法即可,这样一来,更方便,减少代码量,增加工作效率,用到那个方法,便去重写那个方法. HttpServlet 该抽象类,继承了GenericServlet这个类,其中有两个service方法.一个protect的service方 法,其中,两个方法需要的参数对象不同,但在public的service方法中,进行了向下转型,因为HttpServlet继承自GenericServlet,而GenericServlet又实现了Servlet接口,所以Servlet也是 HttpServlet的爷爷类,public方法中,把Servlet的Requst和Response对象,通过向下转型,强 转为HttpServlet的Requset和Response对象,然后再该方法中,调用本类中的protect的 service方法, 如下方法. 该方法中,封装了对请求信息的判断,判断其是get/post请求,然后根据判断结果.执行对应的doget和dopost方法,这样就不用再每一次都进行判断,而程序员只用写一个类,继承自HttpServlet,然后去重写其中的doget或者dopost方法,当服务器收到每次请求的时候,会自动去找父类GenericServlet中的public service方法,然后通过强转,执行protect service方法,然后通过方法中的判断去执行doget或者dopost方法,又因为程序员写的类继承了该类,重写了doget或者dopost方法,所以其实执行的是子类中的doget或dopost方法,这样就完成了想返回的响应请求和实现请求响应的过程… 特别注意!!! 当继承HttpServlet的子类中,如果重写了service方法,得看方法得参数,如果为ServletRequest和ServletResponse,那么服务器再收到请求以后,便不会去父类中,执行父类中的强转得service方法,而是直接执行子类中重写的该方法,然后执行该子类中service中对应得操作… 那么如果子类中,重写了参数为HttpRequest和Httpresponse得service方法,那么服务器在接收到请求以后,会先去父类中执行向下转型得service方法,然后再到子类中,执行该方法,接着执行该方法中对应得操作.]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet注解配置&HTTP]]></title>
    <url>%2F2019%2F07%2F15%2Fervlet%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Servlet3.0 支持注解配置,不用再去配置web.xml了, 创建web项目的时候,选择3.0以上,不用创建web.xml了(JDK6以后,开始支持) 定义一个类,实现servlet接口,重写接口中的方法, 在类上定义注解@webservlet(url-patten),便可以实现,不用web.xml来访问客户需要访问的资源. 同时,一个Servlet可以有多个访问路径,再注解配置中,可以如下配置,实现多个路径访问一个Servlet. 配置中.也可以有多层路径.如下 里边也可以写为/*,*为通配符,优先级最低.HTTP:也叫做超文本传输协议Hyper Text Transfer Protocol *定义了客户端和服务器通信时,发送数据的格式. *基于TCP/IP所以是安全的 *默认端口号80 *基于请求/响应模型:一次请求,对应一次响应. *无状态的:每次请求之间互相独立,不能交互数据. 历史版本: 1.0:每次请求响应都会建立连接. 1.1:复用连接.不在每次断开. 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST(请求方法) /login.html(请求的资源路径) HTTP/1.1(HTTP版本信息) Host: localhost(本机) User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 (浏览器告诉服务器,访问使用的浏览器版本信息,解决了服务器的兼容性) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet工作原理]]></title>
    <url>%2F2019%2F07%2F14%2Fervlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。 public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(&quot;hello.servlet&quot;); } 当用户通过浏览器,输入url访问servlet容器时,即服务器,servlet容器也可以认为是Tomcat(个人理解),Tomcat/servlet容器,会自动实例化一个servlet对象,不需要程序员去创建对象,并且调用servlet中的该方法,注意此方法中需要两个形参.一个Request对象,一个Response对象. 于是我特意去搜了一下这两个对象,发现,服务器在接收到请求的时候,并不是只会自动生成servlet对象,还会生成一个Request对象,在这个对象中,包含了此次请求的数据信息,服务器在检索对应的servlet的时候,会将储存了此次请求信息的Request对象作为实际参数传给服务器的该方法,还有doGet方法和doPost方法. 即可以理解为,Request这个人去找要找的东西(包含的数据信息),服务器检索这些东西的时候,发现某个东西(该Request需要的东西),但是这个东西需要人来拿(即Request对象作为参数)于是服务器把这个Request对象作为实参传给了这个东西(方法)接下来,是Response对象. 服务器在处理完对应的servlet中的方法时,处理完请求数据后,会调用Response对象,把包含此次处理完对应的响应数据调用Response中的方法,响应给客户. Response对象的方法： response.setHeader(String key, String value);//在响应头中添加响应信息,但是同键会被覆盖 response.addHeader(String key, String value);//在响应头中添加响应信息,同键不会被覆盖 response.setContentType(“text/html;charset=utf-8”);//设置响应编码格式 response.sendError(int num, String msg&quot;);//自定义响应状态码 response.getWriter().write(String str);//响应具体的数据给客户端 说到这里,大家应该知道,服务器是怎么调用service方法的了吧.那么,服务器又是怎么知道用户访问的资源是哪一个的呢… 在服务器收到请求的时候,会通过web项目中,web.xml中配置的信息,来配对,]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F07%2F14%2FServlet%2F</url>
    <content type="text"><![CDATA[Servlet:server applet *概念:运行在服务器端的小程序. Servlet就是一个接口,定义了Java类被浏览器访问到(tomcat识别)的规则. 实现Servlet接口,复写方法. 狭义的讲servlet是一个待实现的接口,广义的讲servlet是任何一个实现了servlet这个接口的实现类.一般理解为后者. 快速入门: 创建JavaEE项目 定义一个类,实现Servlet接口,实现接口中的方法,配置Servlet,浏览器需要一个url来访问这个servlet,所以我们需要去配置一个url. 在web.xml中,配置,首先写一个 &lt;servlet&gt; &lt;servlet-name&gt;servlet名字&lt;/servlet-name&gt; &lt;servlet-class&gt;全类名&lt;/servlet-class&gt; &lt;/servlet&gt; 接下来写 &lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet名字&lt;/servlet-name&gt; &lt;url-patten&gt;&lt;/url-patten&gt; &lt;/servlet-mapping&gt; Servlet的执行原理 客户端通过url中的localhost:8080(ip地址:8080端口)找到服务器,然后找到/后面的项目名称,接下来找到最后/的资源. 此时服务器会通过客户端发送过来的请求,去web.xml中,通过url-patten找是否有这一个资源,发现有则发现servlet-name(资源对应的servlet名字),然后通过&lt;servlet&gt;标签中的&lt;servlet-name&gt;找到对应的&lt;servlet-class&gt;,于是Tomcat通过反射把类的字节码文件加载进内存中class.forName(); 创建对象.class.newInstance(); 调用方法---service方法. 1.如果service()方法没有访问Servlet的成员变量也没有访问全局的资源比如静态变量、文件、数据库连接等，而是只使用了当前线程自己的资源，比如非指向全局资源的临时变量、request和response对象等。该方法本身就是线程安全的，不必进行任何的同步控制。 2. 如果service()方法访问了Servlet的成员变量，但是对该变量的操作是只读操作，该方法本身就是线程安全的，不必进行任何的同步控制。 3. 如果service()方法访问了Servlet的成员变量，并且对该变量的操作既有读又有写，通常需要加上同步控制语句。 4. 如果service()方法访问了全局的静态变量，如果同一时刻系统中也可能有其它线程访问该静态变量，如果既有读也有写的操作，通常需要加上同步控制语句。 5. 如果service()方法访问了全局的资源，比如文件、数据库连接等，通常需要加上同步控制语句。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务器软件]]></title>
    <url>%2F2019%2F07%2F14%2FWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[*服务器:安装了服务器软件的计算机. *服务器软件:接收用户请求,处理请求,做出响应. *web服务器:在web服务器中,可以部署web项目,让用户可以通过浏览器来访问. 常见的web服务器软件: webLogic:orcle公司,大型的JavaEE服务器,支持所有的JavaEE规范,收费. webSphere:IBM公司,大型的JavaEE服务器,支持所有的JavaEE规范,收费. JBOSS:JBOSS公司,大型的JavaEE服务器,支持所有JavaEE规范,收费. Tomcat:Apache基金组织,中小型的JavaEE服务器,支持少量JavaEE规范(servlet/jsp)开源,免费. 使用Tomcat服务器. 1:下载Tomcat: 2:安装Tomcat:解压下载下来的压缩包即可. 3:卸载:解压目录即可. 4:Tomcat目录结构: bin:可执行文件. conf:Tomcat的配置文件. lib:依赖jar包. logs:日志文件. temp:临时文件. webapps:存放web项目. work:存放运行时数据. 5: 启动Tomcat: *bin目录下有一个可执行文件startup.bat双击即可启动.(不要关闭控制台). 通过启动以后在浏览器输入localhost:8080即可访问. 配置. 1.直接将项目放到webapps下 *简化部署:将项目打包格式为war,将war包放在webapps目录下,会自动解压缩. 2.通过Tomcat配置文件server.xml在&lt;Host&gt;标签体中配置&lt;Context docBase=&quot;项目存放路径&quot; path=&quot;虚拟路径&quot;/&gt;.通过server.xml配置,不安全,需要重启Tomcat服务器. 3.在conf目录下有一个catalina文件,中有一个locahost,创建任意名称的xml配置文件,在文件中编写,&lt;Context docBase=&quot;项目存放路径&quot; /&gt;虚拟目录为,xml的名称.通过热部署,不需要重启Tomcat服务器,安全. *项目分为静态项目/动态项目: 目录结构 Java动态工程的目录结构: --项目的目录: --WEB--INF目录: --web.xml:web项目的核心配置文件. --classes目录:存放字节码文件的目录. --lib目录:放置依赖的jar包.]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web]]></title>
    <url>%2F2019%2F07%2F14%2FWeb%2F</url>
    <content type="text"><![CDATA[1.web相关概念回顾2.web服务器软件: Tomcat3.Servlet学习 软件架构 1.C/S:客户端/服务器端 2.B/S:浏览器(包含静态资源解析引擎)/服务器端 资源分类 1.静态资源 静态资源可以直接被浏览器解析. 如html,css,JavaScript 2.动态资源 动态资源被访问,先转换为静态资源.再返回给浏览器(这个动作被称为响应.),然后被解析. 如jsp,php,asp/servlet... 网络通信的三要素 1.IP:电子设备(计算机)在网络中的唯一标识. 2.端口:应用程序在计算机中的唯一标识.端口号的范围在,0~65536. 3.传输协议: tcp:经过三次握手,相对安全. udp:不需要握手,但是不安全.]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world]]></title>
    <url>%2F2019%2F07%2F13%2FHello-world-I%2F</url>
    <content type="text"><![CDATA[Hi this is my first Blog!]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记.</tag>
      </tags>
  </entry>
</search>
